{"version":3,"file":"store-Bc8foLYJ.js","sources":["../../../../../node_modules/solid-js/store/dist/store.js"],"sourcesContent":["import { $PROXY, $TRACK, getListener, batch, createSignal } from \"solid-js\";\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: (p = new Proxy(value, proxyTraps$1))\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return (\n    obj != null &&\n    typeof obj === \"object\" &&\n    (obj[$PROXY] ||\n      !(proto = Object.getPrototypeOf(obj)) ||\n      proto === Object.prototype ||\n      Array.isArray(obj))\n  );\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if ((result = item != null && item[$RAW])) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);\n    else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\n    else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes)\n    Object.defineProperty(target, symbol, {\n      value: (nodes = Object.create(null))\n    });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return (nodes[property] = s);\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (\n        getListener() &&\n        (typeof value !== \"function\" || target.hasOwnProperty(property)) &&\n        !(desc && desc.get)\n      )\n        value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === $PROXY ||\n      property === $TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if ((node = getNode(nodes, property, prev))) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const { from = 0, to = current.length - 1, by = 1 } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1\n        ? updateArray(unwrappedStore, args[0])\n        : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (\n    !desc ||\n    desc.get ||\n    desc.set ||\n    !desc.configurable ||\n    property === $PROXY ||\n    property === $NODE\n  )\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  desc.set = v => (target[$PROXY][property] = v);\n  return desc;\n}\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get))\n        value = getNode(nodes, property, value)();\n      else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === $PROXY ||\n      property === $TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined, true));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: (p = new Proxy(value, proxyTraps))\n    });\n    const keys = Object.keys(value),\n      desc = Object.getOwnPropertyDescriptors(value);\n    const proto = Object.getPrototypeOf(value);\n    const isClass =\n      proto !== null &&\n      value !== null &&\n      typeof value === \"object\" &&\n      !Array.isArray(value) &&\n      proto !== Object.prototype;\n    if (isClass) {\n      const descriptors = Object.getOwnPropertyDescriptors(proto);\n      keys.push(...Object.keys(descriptors));\n      Object.assign(desc, descriptors);\n    }\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (isClass && prop === \"constructor\") continue;\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get,\n          configurable: true\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n          set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set,\n          configurable: true\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  const isArray = Array.isArray(target);\n  if (\n    property !== $ROOT &&\n    (!isWrappable(target) ||\n      !isWrappable(previous) ||\n      isArray !== Array.isArray(previous) ||\n      (key && target[key] !== previous[key]))\n  ) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (isArray) {\n    if (\n      target.length &&\n      previous.length &&\n      (!merge || (key && target[0] && target[0][key] != null))\n    ) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (\n        start = 0, end = Math.min(previous.length, target.length);\n        start < end &&\n        (previous[start] === target[start] ||\n          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));\n        start++\n      ) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (\n        end = previous.length - 1, newEnd = target.length - 1;\n        end >= start &&\n        newEnd >= start &&\n        (previous[end] === target[newEnd] ||\n          (key && previous[end] && target[newEnd] && previous[end][key] === target[newEnd][key]));\n        end--, newEnd--\n      ) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const { merge, key = \"id\" } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(\n      v,\n      {\n        [$ROOT]: state\n      },\n      $ROOT,\n      merge,\n      key\n    );\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value)\n      ? producers.get(value) ||\n          (producers.set(value, (proxy = new Proxy(value, setterTraps))), proxy)\n      : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined, true);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, (proxy = new Proxy(state, setterTraps)));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nconst DEV = undefined;\n\nexport { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n"],"names":["$RAW","Symbol","$NODE","$HAS","$SELF","isWrappable","obj","proto","$PROXY","Object","getPrototypeOf","prototype","Array","isArray","unwrap","item","set","Set","result","unwrapped","v","prop","has","isFrozen","slice","add","i","l","length","assign","keys","desc","getOwnPropertyDescriptors","get","getNodes","target","symbol","nodes","defineProperty","value","create","getNode","property","s","createSignal","equals","internal","$","trackSelf","getListener","ownKeys","Reflect","setProperty","state","deleting","prev","len","undefined","node","proxyDescriptor","getOwnPropertyDescriptor","configurable","writable","proxyTraps","receiver","$TRACK","tracked","isFunction","hasOwnProperty","args","batch","apply","wrap","deleteProperty","p","Proxy","isClass","descriptors","push","bind","og","call","createMutable","options","unwrappedStore"],"mappings":"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","x_google_ignoreList":[0]}