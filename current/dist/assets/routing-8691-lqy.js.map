{"version":3,"file":"routing-8691-lqy.js","sources":["../../../../node_modules/@solidjs/router/dist/lifecycle.js","../../../../node_modules/@solidjs/router/dist/utils.js","../../../../node_modules/@solidjs/router/dist/routing.js"],"sourcesContent":["import { isServer } from \"solid-js/web\";\nexport function createBeforeLeave() {\n    let listeners = new Set();\n    function subscribe(listener) {\n        listeners.add(listener);\n        return () => listeners.delete(listener);\n    }\n    let ignore = false;\n    function confirm(to, options) {\n        if (ignore)\n            return !(ignore = false);\n        const e = {\n            to,\n            options,\n            defaultPrevented: false,\n            preventDefault: () => (e.defaultPrevented = true)\n        };\n        for (const l of listeners)\n            l.listener({\n                ...e,\n                from: l.location,\n                retry: (force) => {\n                    force && (ignore = true);\n                    l.navigate(to, { ...options, resolve: false });\n                }\n            });\n        return !e.defaultPrevented;\n    }\n    return {\n        subscribe,\n        confirm\n    };\n}\n// The following supports browser initiated blocking (eg back/forward)\nlet depth;\nexport function saveCurrentDepth() {\n    if (!window.history.state || window.history.state._depth == null) {\n        window.history.replaceState({ ...window.history.state, _depth: window.history.length - 1 }, \"\");\n    }\n    depth = window.history.state._depth;\n}\nif (!isServer) {\n    saveCurrentDepth();\n}\nexport function keepDepth(state) {\n    return {\n        ...state,\n        _depth: window.history.state && window.history.state._depth\n    };\n}\nexport function notifyIfNotBlocked(notify, block) {\n    let ignore = false;\n    return () => {\n        const prevDepth = depth;\n        saveCurrentDepth();\n        const delta = prevDepth == null ? null : depth - prevDepth;\n        if (ignore) {\n            ignore = false;\n            return;\n        }\n        if (delta && block(delta)) {\n            ignore = true;\n            window.history.go(-delta);\n        }\n        else {\n            notify();\n        }\n    };\n}\n","import { createMemo, getOwner, runWithOwner } from \"solid-js\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\nexport const mockBase = \"http://sr\";\nexport function normalizePath(path, omitSlash = false) {\n    const s = path.replace(trimPathRegex, \"$1\");\n    return s ? (omitSlash || /^[?#]/.test(s) ? s : \"/\" + s) : \"\";\n}\nexport function resolvePath(base, path, from) {\n    if (hasSchemeRegex.test(path)) {\n        return undefined;\n    }\n    const basePath = normalizePath(base);\n    const fromPath = from && normalizePath(from);\n    let result = \"\";\n    if (!fromPath || path.startsWith(\"/\")) {\n        result = basePath;\n    }\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n        result = basePath + fromPath;\n    }\n    else {\n        result = fromPath;\n    }\n    return (result || \"/\") + normalizePath(path, !result);\n}\nexport function invariant(value, message) {\n    if (value == null) {\n        throw new Error(message);\n    }\n    return value;\n}\nexport function joinPaths(from, to) {\n    return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\n}\nexport function extractSearchParams(url) {\n    const params = {};\n    url.searchParams.forEach((value, key) => {\n        if (key in params) {\n            if (Array.isArray(params[key]))\n                params[key].push(value);\n            else\n                params[key] = [params[key], value];\n        }\n        else\n            params[key] = value;\n    });\n    return params;\n}\nexport function createMatcher(path, partial, matchFilters) {\n    const [pattern, splat] = path.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    const len = segments.length;\n    return (location) => {\n        const locSegments = location.split(\"/\").filter(Boolean);\n        const lenDiff = locSegments.length - len;\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n            return null;\n        }\n        const match = {\n            path: len ? \"\" : \"/\",\n            params: {}\n        };\n        const matchFilter = (s) => matchFilters === undefined ? undefined : matchFilters[s];\n        for (let i = 0; i < len; i++) {\n            const segment = segments[i];\n            const dynamic = segment[0] === \":\";\n            const locSegment = dynamic ? locSegments[i] : locSegments[i].toLowerCase();\n            const key = dynamic ? segment.slice(1) : segment.toLowerCase();\n            if (dynamic && matchSegment(locSegment, matchFilter(key))) {\n                match.params[key] = locSegment;\n            }\n            else if (dynamic || !matchSegment(locSegment, key)) {\n                return null;\n            }\n            match.path += `/${locSegment}`;\n        }\n        if (splat) {\n            const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n            if (matchSegment(remainder, matchFilter(splat))) {\n                match.params[splat] = remainder;\n            }\n            else {\n                return null;\n            }\n        }\n        return match;\n    };\n}\nfunction matchSegment(input, filter) {\n    const isEqual = (s) => s === input;\n    if (filter === undefined) {\n        return true;\n    }\n    else if (typeof filter === \"string\") {\n        return isEqual(filter);\n    }\n    else if (typeof filter === \"function\") {\n        return filter(input);\n    }\n    else if (Array.isArray(filter)) {\n        return filter.some(isEqual);\n    }\n    else if (filter instanceof RegExp) {\n        return filter.test(input);\n    }\n    return false;\n}\nexport function scoreRoute(route) {\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMemoObject(fn) {\n    const map = new Map();\n    const owner = getOwner();\n    return new Proxy({}, {\n        get(_, property) {\n            if (!map.has(property)) {\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\n            }\n            return map.get(property)();\n        },\n        getOwnPropertyDescriptor() {\n            return {\n                enumerable: true,\n                configurable: true\n            };\n        },\n        ownKeys() {\n            return Reflect.ownKeys(fn());\n        }\n    });\n}\nexport function mergeSearchString(search, params) {\n    const merged = new URLSearchParams(search);\n    Object.entries(params).forEach(([key, value]) => {\n        if (value == null || value === \"\" || (value instanceof Array && !value.length)) {\n            merged.delete(key);\n        }\n        else {\n            if (value instanceof Array) {\n                // Delete all instances of the key before appending\n                merged.delete(key);\n                value.forEach(v => {\n                    merged.append(key, String(v));\n                });\n            }\n            else {\n                merged.set(key, String(value));\n            }\n        }\n    });\n    const s = merged.toString();\n    return s ? `?${s}` : \"\";\n}\nexport function expandOptionals(pattern) {\n    let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n    if (!match)\n        return [pattern];\n    let prefix = pattern.slice(0, match.index);\n    let suffix = pattern.slice(match.index + match[0].length);\n    const prefixes = [prefix, (prefix += match[1])];\n    // This section handles adjacent optional params. We don't actually want all permuations since\n    // that will lead to equivalent routes which have the same number of params. For example\n    // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n    // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n    // ensure predictability where earlier params have precidence.\n    while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\n        prefixes.push((prefix += match[1]));\n        suffix = suffix.slice(match[0].length);\n    }\n    return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\n}\n","import { runWithOwner, batch } from \"solid-js\";\nimport { createComponent, createContext, createMemo, createRenderEffect, createSignal, on, onCleanup, untrack, useContext, startTransition, resetErrorBoundaries } from \"solid-js\";\nimport { isServer, getRequestEvent } from \"solid-js/web\";\nimport { createBeforeLeave } from \"./lifecycle.js\";\nimport { mockBase, createMemoObject, extractSearchParams, invariant, resolvePath, createMatcher, joinPaths, scoreRoute, mergeSearchString, expandOptionals } from \"./utils.js\";\nconst MAX_REDIRECTS = 100;\nexport const RouterContextObj = createContext();\nexport const RouteContextObj = createContext();\nexport const useRouter = () => invariant(useContext(RouterContextObj), \"<A> and 'use' router primitives can be only used inside a Route.\");\nlet TempRoute;\nexport const useRoute = () => TempRoute || useContext(RouteContextObj) || useRouter().base;\nexport const useResolvedPath = (path) => {\n    const route = useRoute();\n    return createMemo(() => route.resolvePath(path()));\n};\nexport const useHref = (to) => {\n    const router = useRouter();\n    return createMemo(() => {\n        const to_ = to();\n        return to_ !== undefined ? router.renderPath(to_) : to_;\n    });\n};\n/**\n * Retrieves method to do navigation. The method accepts a path to navigate to and an optional object with the following options:\n *\n * - resolve (*boolean*, default `true`): resolve the path against the current route\n * - replace (*boolean*, default `false`): replace the history entry\n * - scroll (*boolean*, default `true`): scroll to top after navigation\n * - state (*any*, default `undefined`): pass custom state to `location.state`\n *\n * **Note**: The state is serialized using the structured clone algorithm which does not support all object types.\n *\n * @example\n * ```js\n * const navigate = useNavigate();\n *\n * if (unauthorized) {\n *   navigate(\"/login\", { replace: true });\n * }\n * ```\n */\nexport const useNavigate = () => useRouter().navigatorFactory();\n/**\n * Retrieves reactive `location` object useful for getting things like `pathname`.\n *\n * @example\n * ```js\n * const location = useLocation();\n *\n * const pathname = createMemo(() => parsePath(location.pathname));\n * ```\n */\nexport const useLocation = () => useRouter().location;\n/**\n * Retrieves signal that indicates whether the route is currently in a *Transition*.\n * Useful for showing stale/pending state when the route resolution is *Suspended* during concurrent rendering.\n *\n * @example\n * ```js\n * const isRouting = useIsRouting();\n *\n * return (\n *   <div classList={{ \"grey-out\": isRouting() }}>\n *     <MyAwesomeContent />\n *   </div>\n * );\n * ```\n */\nexport const useIsRouting = () => useRouter().isRouting;\n/**\n * usePreloadRoute returns a function that can be used to preload a route manual.\n * This is what happens automatically with link hovering and similar focus based behavior, but it is available here as an API.\n *\n * @example\n * ```js\n * const preload = usePreloadRoute();\n *\n * preload(`/users/settings`, { preloadData: true });\n * ```\n */\nexport const usePreloadRoute = () => {\n    const pre = useRouter().preloadRoute;\n    return (url, options = {}) => pre(url instanceof URL ? url : new URL(url, mockBase), options.preloadData);\n};\n/**\n * `useMatch` takes an accessor that returns the path and creates a `Memo` that returns match information if the current path matches the provided path.\n * Useful for determining if a given path matches the current route.\n *\n * @example\n * ```js\n * const match = useMatch(() => props.href);\n *\n * return <div classList={{ active: Boolean(match()) }} />;\n * ```\n */\nexport const useMatch = (path, matchFilters) => {\n    const location = useLocation();\n    const matchers = createMemo(() => expandOptionals(path()).map(path => createMatcher(path, undefined, matchFilters)));\n    return createMemo(() => {\n        for (const matcher of matchers()) {\n            const match = matcher(location.pathname);\n            if (match)\n                return match;\n        }\n    });\n};\n/**\n * `useCurrentMatches` returns all the matches for the current matched route.\n * Useful for getting all the route information.\n *\n * @example\n * ```js\n * const matches = useCurrentMatches();\n *\n * const breadcrumbs = createMemo(() => matches().map(m => m.route.info.breadcrumb))\n * ```\n */\nexport const useCurrentMatches = () => useRouter().matches;\n/**\n * Retrieves a reactive, store-like object containing the current route path parameters as defined in the Route.\n *\n * @example\n * ```js\n * const params = useParams();\n *\n * // fetch user based on the id path parameter\n * const [user] = createResource(() => params.id, fetchUser);\n * ```\n */\nexport const useParams = () => useRouter().params;\n/**\n * Retrieves a tuple containing a reactive object to read the current location's query parameters and a method to update them.\n * The object is a proxy so you must access properties to subscribe to reactive updates.\n * **Note** that values will be strings and property names will retain their casing.\n *\n * The setter method accepts an object whose entries will be merged into the current query string.\n * Values `''`, `undefined` and `null` will remove the key from the resulting query string.\n * Updates will behave just like a navigation and the setter accepts the same optional second parameter as `navigate` and auto-scrolling is disabled by default.\n *\n * @examples\n * ```js\n * const [searchParams, setSearchParams] = useSearchParams();\n *\n * return (\n *   <div>\n *     <span>Page: {searchParams.page}</span>\n *     <button\n *       onClick={() =>\n *         setSearchParams({ page: (parseInt(searchParams.page) || 0) + 1 })\n *       }\n *     >\n *       Next Page\n *     </button>\n *   </div>\n * );\n * ```\n */\nexport const useSearchParams = () => {\n    const location = useLocation();\n    const navigate = useNavigate();\n    const setSearchParams = (params, options) => {\n        const searchString = untrack(() => mergeSearchString(location.search, params) + location.hash);\n        navigate(searchString, {\n            scroll: false,\n            resolve: false,\n            ...options\n        });\n    };\n    return [location.query, setSearchParams];\n};\n/**\n * useBeforeLeave takes a function that will be called prior to leaving a route.\n * The function will be called with:\n *\n * - from (*Location*): current location (before change).\n * - to (*string | number*): path passed to `navigate`.\n * - options (*NavigateOptions*): options passed to navigate.\n * - preventDefault (*function*): call to block the route change.\n * - defaultPrevented (*readonly boolean*): `true` if any previously called leave handlers called `preventDefault`.\n * - retry (*function*, force?: boolean ): call to retry the same navigation, perhaps after confirming with the user. Pass `true` to skip running the leave handlers again (i.e. force navigate without confirming).\n *\n * @example\n * ```js\n * useBeforeLeave((e: BeforeLeaveEventArgs) => {\n *   if (form.isDirty && !e.defaultPrevented) {\n *     // preventDefault to block immediately and prompt user async\n *     e.preventDefault();\n *     setTimeout(() => {\n *       if (window.confirm(\"Discard unsaved changes - are you sure?\")) {\n *         // user wants to proceed anyway so retry with force=true\n *         e.retry(true);\n *       }\n *     }, 100);\n *   }\n * });\n * ```\n */\nexport const useBeforeLeave = (listener) => {\n    const s = useRouter().beforeLeave.subscribe({\n        listener,\n        location: useLocation(),\n        navigate: useNavigate()\n    });\n    onCleanup(s);\n};\nexport function createRoutes(routeDef, base = \"\") {\n    const { component, preload, load, children, info } = routeDef;\n    const isLeaf = !children || (Array.isArray(children) && !children.length);\n    const shared = {\n        key: routeDef,\n        component,\n        preload: preload || load,\n        info\n    };\n    return asArray(routeDef.path).reduce((acc, originalPath) => {\n        for (const expandedPath of expandOptionals(originalPath)) {\n            const path = joinPaths(base, expandedPath);\n            let pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n            pattern = pattern\n                .split(\"/\")\n                .map((s) => {\n                return s.startsWith(\":\") || s.startsWith(\"*\") ? s : encodeURIComponent(s);\n            })\n                .join(\"/\");\n            acc.push({\n                ...shared,\n                originalPath,\n                pattern,\n                matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)\n            });\n        }\n        return acc;\n    }, []);\n}\nexport function createBranch(routes, index = 0) {\n    return {\n        routes,\n        score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\n        matcher(location) {\n            const matches = [];\n            for (let i = routes.length - 1; i >= 0; i--) {\n                const route = routes[i];\n                const match = route.matcher(location);\n                if (!match) {\n                    return null;\n                }\n                matches.unshift({\n                    ...match,\n                    route\n                });\n            }\n            return matches;\n        }\n    };\n}\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\nexport function createBranches(routeDef, base = \"\", stack = [], branches = []) {\n    const routeDefs = asArray(routeDef);\n    for (let i = 0, len = routeDefs.length; i < len; i++) {\n        const def = routeDefs[i];\n        if (def && typeof def === \"object\") {\n            if (!def.hasOwnProperty(\"path\"))\n                def.path = \"\";\n            const routes = createRoutes(def, base);\n            for (const route of routes) {\n                stack.push(route);\n                const isEmptyArray = Array.isArray(def.children) && def.children.length === 0;\n                if (def.children && !isEmptyArray) {\n                    createBranches(def.children, route.pattern, stack, branches);\n                }\n                else {\n                    const branch = createBranch([...stack], branches.length);\n                    branches.push(branch);\n                }\n                stack.pop();\n            }\n        }\n    }\n    // Stack will be empty on final return\n    return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\n}\nexport function getRouteMatches(branches, location) {\n    for (let i = 0, len = branches.length; i < len; i++) {\n        const match = branches[i].matcher(location);\n        if (match) {\n            return match;\n        }\n    }\n    return [];\n}\nfunction createLocation(path, state, queryWrapper) {\n    const origin = new URL(mockBase);\n    const url = createMemo(prev => {\n        const path_ = path();\n        try {\n            return new URL(path_, origin);\n        }\n        catch (err) {\n            console.error(`Invalid path ${path_}`);\n            return prev;\n        }\n    }, origin, {\n        equals: (a, b) => a.href === b.href\n    });\n    const pathname = createMemo(() => url().pathname);\n    const search = createMemo(() => url().search, true);\n    const hash = createMemo(() => url().hash);\n    const key = () => \"\";\n    const queryFn = on(search, () => extractSearchParams(url()));\n    return {\n        get pathname() {\n            return pathname();\n        },\n        get search() {\n            return search();\n        },\n        get hash() {\n            return hash();\n        },\n        get state() {\n            return state();\n        },\n        get key() {\n            return key();\n        },\n        query: queryWrapper ? queryWrapper(queryFn) : createMemoObject(queryFn)\n    };\n}\nlet intent;\nexport function getIntent() {\n    return intent;\n}\nlet inPreloadFn = false;\nexport function getInPreloadFn() {\n    return inPreloadFn;\n}\nexport function setInPreloadFn(value) {\n    inPreloadFn = value;\n}\nexport function createRouterContext(integration, branches, getContext, options = {}) {\n    const { signal: [source, setSource], utils = {} } = integration;\n    const parsePath = utils.parsePath || (p => p);\n    const renderPath = utils.renderPath || (p => p);\n    const beforeLeave = utils.beforeLeave || createBeforeLeave();\n    const basePath = resolvePath(\"\", options.base || \"\");\n    if (basePath === undefined) {\n        throw new Error(`${basePath} is not a valid base path`);\n    }\n    else if (basePath && !source().value) {\n        setSource({ value: basePath, replace: true, scroll: false });\n    }\n    const [isRouting, setIsRouting] = createSignal(false);\n    // Keep track of last target, so that last call to transition wins\n    let lastTransitionTarget;\n    // Transition the location to a new value\n    const transition = (newIntent, newTarget) => {\n        if (newTarget.value === reference() && newTarget.state === state())\n            return;\n        if (lastTransitionTarget === undefined)\n            setIsRouting(true);\n        intent = newIntent;\n        lastTransitionTarget = newTarget;\n        startTransition(() => {\n            if (lastTransitionTarget !== newTarget)\n                return;\n            setReference(lastTransitionTarget.value);\n            setState(lastTransitionTarget.state);\n            resetErrorBoundaries();\n            if (!isServer)\n                submissions[1](subs => subs.filter(s => s.pending));\n        }).finally(() => {\n            if (lastTransitionTarget !== newTarget)\n                return;\n            // Batch, in order for isRouting and final source update to happen together\n            batch(() => {\n                intent = undefined;\n                if (newIntent === \"navigate\")\n                    navigateEnd(lastTransitionTarget);\n                setIsRouting(false);\n                lastTransitionTarget = undefined;\n            });\n        });\n    };\n    const [reference, setReference] = createSignal(source().value);\n    const [state, setState] = createSignal(source().state);\n    const location = createLocation(reference, state, utils.queryWrapper);\n    const referrers = [];\n    const submissions = createSignal(isServer ? initFromFlash() : []);\n    const matches = createMemo(() => {\n        if (typeof options.transformUrl === \"function\") {\n            return getRouteMatches(branches(), options.transformUrl(location.pathname));\n        }\n        return getRouteMatches(branches(), location.pathname);\n    });\n    const buildParams = () => {\n        const m = matches();\n        const params = {};\n        for (let i = 0; i < m.length; i++) {\n            Object.assign(params, m[i].params);\n        }\n        return params;\n    };\n    const params = utils.paramsWrapper\n        ? utils.paramsWrapper(buildParams, branches)\n        : createMemoObject(buildParams);\n    const baseRoute = {\n        pattern: basePath,\n        path: () => basePath,\n        outlet: () => null,\n        resolvePath(to) {\n            return resolvePath(basePath, to);\n        }\n    };\n    // Create a native transition, when source updates\n    createRenderEffect(on(source, source => transition(\"native\", source), { defer: true }));\n    return {\n        base: baseRoute,\n        location,\n        params,\n        isRouting,\n        renderPath,\n        parsePath,\n        navigatorFactory,\n        matches,\n        beforeLeave,\n        preloadRoute,\n        singleFlight: options.singleFlight === undefined ? true : options.singleFlight,\n        submissions\n    };\n    function navigateFromRoute(route, to, options) {\n        // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\n        untrack(() => {\n            if (typeof to === \"number\") {\n                if (!to) {\n                    // A delta of 0 means stay at the current location, so it is ignored\n                }\n                else if (utils.go) {\n                    utils.go(to);\n                }\n                else {\n                    console.warn(\"Router integration does not support relative routing\");\n                }\n                return;\n            }\n            const queryOnly = !to || to[0] === \"?\";\n            const { replace, resolve, scroll, state: nextState } = {\n                replace: false,\n                resolve: !queryOnly,\n                scroll: true,\n                ...options\n            };\n            const resolvedTo = resolve\n                ? route.resolvePath(to)\n                : resolvePath((queryOnly && location.pathname) || \"\", to);\n            if (resolvedTo === undefined) {\n                throw new Error(`Path '${to}' is not a routable path`);\n            }\n            else if (referrers.length >= MAX_REDIRECTS) {\n                throw new Error(\"Too many redirects\");\n            }\n            const current = reference();\n            if (resolvedTo !== current || nextState !== state()) {\n                if (isServer) {\n                    const e = getRequestEvent();\n                    e && (e.response = { status: 302, headers: new Headers({ Location: resolvedTo }) });\n                    setSource({ value: resolvedTo, replace, scroll, state: nextState });\n                }\n                else if (beforeLeave.confirm(resolvedTo, options)) {\n                    referrers.push({ value: current, replace, scroll, state: state() });\n                    transition(\"navigate\", {\n                        value: resolvedTo,\n                        state: nextState\n                    });\n                }\n            }\n        });\n    }\n    function navigatorFactory(route) {\n        // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\n        route = route || useContext(RouteContextObj) || baseRoute;\n        return (to, options) => navigateFromRoute(route, to, options);\n    }\n    function navigateEnd(next) {\n        const first = referrers[0];\n        if (first) {\n            setSource({\n                ...next,\n                replace: first.replace,\n                scroll: first.scroll\n            });\n            referrers.length = 0;\n        }\n    }\n    function preloadRoute(url, preloadData) {\n        const matches = getRouteMatches(branches(), url.pathname);\n        const prevIntent = intent;\n        intent = \"preload\";\n        for (let match in matches) {\n            const { route, params } = matches[match];\n            route.component &&\n                route.component.preload &&\n                route.component.preload();\n            const { preload } = route;\n            inPreloadFn = true;\n            preloadData &&\n                preload &&\n                runWithOwner(getContext(), () => preload({\n                    params,\n                    location: {\n                        pathname: url.pathname,\n                        search: url.search,\n                        hash: url.hash,\n                        query: extractSearchParams(url),\n                        state: null,\n                        key: \"\"\n                    },\n                    intent: \"preload\"\n                }));\n            inPreloadFn = false;\n        }\n        intent = prevIntent;\n    }\n    function initFromFlash() {\n        const e = getRequestEvent();\n        return (e && e.router && e.router.submission ? [e.router.submission] : []);\n    }\n}\nexport function createRouteContext(router, parent, outlet, match) {\n    const { base, location, params } = router;\n    const { pattern, component, preload } = match().route;\n    const path = createMemo(() => match().path);\n    component &&\n        component.preload &&\n        component.preload();\n    inPreloadFn = true;\n    const data = preload ? preload({ params, location, intent: intent || \"initial\" }) : undefined;\n    inPreloadFn = false;\n    const route = {\n        parent,\n        pattern,\n        path,\n        outlet: () => component\n            ? createComponent(component, {\n                params,\n                location,\n                data,\n                get children() {\n                    return outlet();\n                }\n            })\n            : outlet(),\n        resolvePath(to) {\n            return resolvePath(base.path(), to, path());\n        }\n    };\n    return route;\n}\n"],"names":["createBeforeLeave","listeners","Set","subscribe","listener","add","delete","ignore","confirm","to","options","e","defaultPrevented","preventDefault","l","from","location","retry","force","navigate","resolve","depth","saveCurrentDepth","window","history","state","_depth","replaceState","length","isServer","keepDepth","notifyIfNotBlocked","notify","block","prevDepth","delta","go","hasSchemeRegex","trimPathRegex","mockBase","normalizePath","path","omitSlash","s","replace","test","resolvePath","base","basePath","fromPath","result","startsWith","toLowerCase","indexOf","invariant","value","message","Error","joinPaths","extractSearchParams","url","params","searchParams","forEach","key","Array","isArray","push","createMatcher","partial","matchFilters","pattern","splat","split","segments","filter","Boolean","len","locSegments","lenDiff","undefined","match","matchFilter","i","segment","dynamic","locSegment","slice","matchSegment","remainder","join","input","isEqual","some","RegExp","scoreRoute","route","reduce","score","createMemoObject","fn","map","Map","owner","getOwner","Proxy","get","_","property","has","runWithOwner","set","createMemo","getOwnPropertyDescriptor","enumerable","configurable","ownKeys","Reflect","expandOptionals","exec","prefix","index","suffix","prefixes","results","expansion","p","MAX_REDIRECTS","RouterContextObj","createContext","RouteContextObj","useRouter","useContext","useRoute","useResolvedPath","useHref","router","to_","renderPath","useLocation","createRoutes","routeDef","component","preload","load","children","info","isLeaf","shared","asArray","acc","originalPath","expandedPath","encodeURIComponent","matcher","createBranch","routes","matches","unshift","createBranches","stack","branches","routeDefs","def","hasOwnProperty","isEmptyArray","branch","pop","sort","a","b","getRouteMatches","createLocation","queryWrapper","origin","URL","prev","path_","console","error","equals","href","pathname","search","hash","queryFn","on","query","intent","getIntent","createRouterContext","integration","getContext","signal","source","setSource","utils","parsePath","beforeLeave","scroll","isRouting","setIsRouting","createSignal","lastTransitionTarget","transition","newIntent","newTarget","reference","startTransition","setReference","setState","resetErrorBoundaries","submissions","subs","pending","finally","batch","navigateEnd","referrers","initFromFlash","transformUrl","buildParams","m","Object","assign","paramsWrapper","baseRoute","outlet","createRenderEffect","defer","navigatorFactory","preloadRoute","singleFlight","navigateFromRoute","untrack","warn","queryOnly","nextState","resolvedTo","current","getRequestEvent","response","status","headers","Headers","Location","next","first","preloadData","prevIntent","submission","createRouteContext","parent","data","createComponent"],"mappings":"2TACO,SAASA,IAAoB,CAChC,IAAIC,EAAY,IAAIC,IACpB,SAASC,EAAUC,EAAU,CACzBH,OAAAA,EAAUI,IAAID,CAAQ,EACf,IAAMH,EAAUK,OAAOF,CAAQ,CAC1C,CACA,IAAIG,EAAS,GACb,SAASC,EAAQC,EAAIC,EAAS,CAC1B,GAAIH,EACA,MAAO,EAAEA,EAAS,IACtB,MAAMI,EAAI,CACNF,GAAAA,EACAC,QAAAA,EACAE,iBAAkB,GAClBC,eAAgBA,IAAOF,EAAEC,iBAAmB,EAC/C,EACD,UAAWE,KAAKb,EACZa,EAAEV,SAAS,CACP,GAAGO,EACHI,KAAMD,EAAEE,SACRC,MAAQC,GAAU,CACdA,IAAUX,EAAS,IACnBO,EAAEK,SAASV,EAAI,CAAE,GAAGC,EAASU,QAAS,EAAM,CAAC,CACjD,CACJ,CAAC,EACL,MAAO,CAACT,EAAEC,gBACd,CACA,MAAO,CACHT,UAAAA,EACAK,QAAAA,CACH,CACL,CAEA,IAAIa,EACG,SAASC,GAAmB,EAC3B,CAACC,OAAOC,QAAQC,OAASF,OAAOC,QAAQC,MAAMC,QAAU,OACxDH,OAAOC,QAAQG,aAAa,CAAE,GAAGJ,OAAOC,QAAQC,MAAOC,OAAQH,OAAOC,QAAQI,OAAS,CAAG,EAAE,EAAE,EAElGP,EAAQE,OAAOC,QAAQC,MAAMC,MACjC,CACKG,GACDP,EAAkB,EAEf,SAASQ,GAAUL,EAAO,CAC7B,MAAO,CACH,GAAGA,EACHC,OAAQH,OAAOC,QAAQC,OAASF,OAAOC,QAAQC,MAAMC,MACxD,CACL,CACO,SAASK,GAAmBC,EAAQC,EAAO,CAC9C,IAAI1B,EAAS,GACb,MAAO,IAAM,CACT,MAAM2B,EAAYb,EAClBC,EAAkB,EAClB,MAAMa,EAAQD,GAAa,KAAO,KAAOb,EAAQa,EACjD,GAAI3B,EAAQ,CACRA,EAAS,GACT,MACJ,CACI4B,GAASF,EAAME,CAAK,GACpB5B,EAAS,GACTgB,OAAOC,QAAQY,GAAG,CAACD,CAAK,GAGxBH,EAAQ,CAEf,CACL,CCnEA,MAAMK,GAAiB,wBACjBC,GAAgB,iBACTC,GAAW,YACjB,SAASC,EAAcC,EAAMC,EAAY,GAAO,CACnD,MAAMC,EAAIF,EAAKG,QAAQN,GAAe,IAAI,EAC1C,OAAOK,EAAKD,GAAa,QAAQG,KAAKF,CAAC,EAAIA,EAAI,IAAMA,EAAK,EAC9D,CACO,SAASG,EAAYC,EAAMN,EAAM1B,EAAM,CAC1C,GAAIsB,GAAeQ,KAAKJ,CAAI,EACxB,OAEJ,MAAMO,EAAWR,EAAcO,CAAI,EAC7BE,EAAWlC,GAAQyB,EAAczB,CAAI,EAC3C,IAAImC,EAAS,GACb,MAAI,CAACD,GAAYR,EAAKU,WAAW,GAAG,EAChCD,EAASF,EAEJC,EAASG,cAAcC,QAAQL,EAASI,YAAW,CAAE,IAAM,EAChEF,EAASF,EAAWC,EAGpBC,EAASD,GAELC,GAAU,KAAOV,EAAcC,EAAM,CAACS,CAAM,CACxD,CACO,SAASI,GAAUC,EAAOC,EAAS,CACtC,GAAID,GAAS,KACT,MAAM,IAAIE,MAAMD,CAAO,EAE3B,OAAOD,CACX,CACO,SAASG,GAAU3C,EAAMN,EAAI,CAChC,OAAO+B,EAAczB,CAAI,EAAE6B,QAAQ,eAAgB,EAAE,EAAIJ,EAAc/B,CAAE,CAC7E,CACO,SAASkD,EAAoBC,EAAK,CACrC,MAAMC,EAAS,CAAE,EACjBD,OAAAA,EAAIE,aAAaC,QAAQ,CAACR,EAAOS,IAAQ,CACjCA,KAAOH,EACHI,MAAMC,QAAQL,EAAOG,CAAG,CAAC,EACzBH,EAAOG,CAAG,EAAEG,KAAKZ,CAAK,EAEtBM,EAAOG,CAAG,EAAI,CAACH,EAAOG,CAAG,EAAGT,CAAK,EAGrCM,EAAOG,CAAG,EAAIT,CACtB,CAAC,EACMM,CACX,CACO,SAASO,GAAc3B,EAAM4B,EAASC,EAAc,CACvD,KAAM,CAACC,EAASC,CAAK,EAAI/B,EAAKgC,MAAM,KAAM,CAAC,EACrCC,EAAWH,EAAQE,MAAM,GAAG,EAAEE,OAAOC,OAAO,EAC5CC,EAAMH,EAAS9C,OACrB,OAAQZ,GAAa,CACjB,MAAM8D,EAAc9D,EAASyD,MAAM,GAAG,EAAEE,OAAOC,OAAO,EAChDG,EAAUD,EAAYlD,OAASiD,EACrC,GAAIE,EAAU,GAAMA,EAAU,GAAKP,IAAUQ,QAAa,CAACX,EACvD,OAAO,KAEX,MAAMY,EAAQ,CACVxC,KAAMoC,EAAM,GAAK,IACjBhB,OAAQ,CAAA,CACX,EACKqB,EAAevC,GAAM2B,IAAiBU,OAAYA,OAAYV,EAAa3B,CAAC,EAClF,QAASwC,EAAI,EAAGA,EAAIN,EAAKM,IAAK,CAC1B,MAAMC,EAAUV,EAASS,CAAC,EACpBE,EAAUD,EAAQ,CAAC,IAAM,IACzBE,EAAaD,EAAUP,EAAYK,CAAC,EAAIL,EAAYK,CAAC,EAAE/B,YAAa,EACpEY,EAAMqB,EAAUD,EAAQG,MAAM,CAAC,EAAIH,EAAQhC,YAAa,EAC9D,GAAIiC,GAAWG,EAAaF,EAAYJ,EAAYlB,CAAG,CAAC,EACpDiB,EAAMpB,OAAOG,CAAG,EAAIsB,UAEfD,GAAW,CAACG,EAAaF,EAAYtB,CAAG,EAC7C,OAAO,KAEXiB,EAAMxC,MAAQ,IAAI6C,CAAU,EAChC,CACA,GAAId,EAAO,CACP,MAAMiB,EAAYV,EAAUD,EAAYS,MAAM,CAACR,CAAO,EAAEW,KAAK,GAAG,EAAI,GACpE,GAAIF,EAAaC,EAAWP,EAAYV,CAAK,CAAC,EAC1CS,EAAMpB,OAAOW,CAAK,EAAIiB,MAGtB,QAAO,IAEf,CACA,OAAOR,CACV,CACL,CACA,SAASO,EAAaG,EAAOhB,EAAQ,CACjC,MAAMiB,EAAWjD,GAAMA,IAAMgD,EAC7B,OAAIhB,IAAWK,OACJ,GAEF,OAAOL,GAAW,SAChBiB,EAAQjB,CAAM,EAEhB,OAAOA,GAAW,WAChBA,EAAOgB,CAAK,EAEd1B,MAAMC,QAAQS,CAAM,EAClBA,EAAOkB,KAAKD,CAAO,EAErBjB,aAAkBmB,OAChBnB,EAAO9B,KAAK8C,CAAK,EAErB,EACX,CACO,SAASI,GAAWC,EAAO,CAC9B,KAAM,CAACzB,EAASC,CAAK,EAAIwB,EAAMzB,QAAQE,MAAM,KAAM,CAAC,EAC9CC,EAAWH,EAAQE,MAAM,GAAG,EAAEE,OAAOC,OAAO,EAClD,OAAOF,EAASuB,OAAO,CAACC,EAAOd,IAAYc,GAASd,EAAQjC,WAAW,GAAG,EAAI,EAAI,GAAIuB,EAAS9C,QAAU4C,IAAUQ,OAAY,EAAI,EAAE,CACzI,CACO,SAASmB,EAAiBC,EAAI,CACjC,MAAMC,EAAM,IAAIC,IACVC,EAAQC,GAAU,EACxB,OAAO,IAAIC,MAAM,GAAI,CACjBC,IAAIC,EAAGC,EAAU,CACb,OAAKP,EAAIQ,IAAID,CAAQ,GACjBE,EAAaP,EAAO,IAAMF,EAAIU,IAAIH,EAAUI,EAAW,IAAMZ,EAAE,EAAGQ,CAAQ,CAAC,CAAC,CAAC,EAE1EP,EAAIK,IAAIE,CAAQ,EAAG,CAC7B,EACDK,0BAA2B,CACvB,MAAO,CACHC,WAAY,GACZC,aAAc,EACjB,CACJ,EACDC,SAAU,CACN,OAAOC,QAAQD,QAAQhB,GAAI,CAC/B,CACJ,CAAC,CACL,CAuBO,SAASkB,EAAgB/C,EAAS,CACrC,IAAIU,EAAQ,kBAAkBsC,KAAKhD,CAAO,EAC1C,GAAI,CAACU,EACD,MAAO,CAACV,CAAO,EACnB,IAAIiD,EAASjD,EAAQgB,MAAM,EAAGN,EAAMwC,KAAK,EACrCC,EAASnD,EAAQgB,MAAMN,EAAMwC,MAAQxC,EAAM,CAAC,EAAErD,MAAM,EACxD,MAAM+F,EAAW,CAACH,EAASA,GAAUvC,EAAM,CAAC,CAAC,EAM7C,KAAQA,EAAQ,kBAAkBsC,KAAKG,CAAM,GACzCC,EAASxD,KAAMqD,GAAUvC,EAAM,CAAC,CAAE,EAClCyC,EAASA,EAAOnC,MAAMN,EAAM,CAAC,EAAErD,MAAM,EAEzC,OAAO0F,EAAgBI,CAAM,EAAEzB,OAAO,CAAC2B,EAASC,IAAc,CAAC,GAAGD,EAAS,GAAGD,EAAStB,IAAIyB,GAAKA,EAAID,CAAS,CAAC,EAAG,EAAE,CACvH,CCxKA,MAAME,GAAgB,IACTC,GAAmBC,EAAa,EAChCC,GAAkBD,EAAa,EAC/BE,EAAYA,IAAM7E,GAAU8E,EAAWJ,EAAgB,EAAG,kEAAkE,EAE5HK,GAAWA,IAAmBD,EAAWF,EAAe,GAAKC,EAAW,EAACpF,KACzEuF,GAAmB7F,GAAS,CACrC,MAAMuD,EAAQqC,GAAU,EACxB,OAAOrB,EAAW,IAAMhB,EAAMlD,YAAYL,EAAM,CAAA,CAAC,CACrD,EACa8F,GAAW9H,GAAO,CAC3B,MAAM+H,EAASL,EAAW,EAC1B,OAAOnB,EAAW,IAAM,CACpB,MAAMyB,EAAMhI,EAAI,EAChB,OAAOgI,IAAQzD,OAAYwD,EAAOE,WAAWD,CAAG,EAAIA,CACxD,CAAC,CACL,EA+BaE,GAAcA,IAAMR,IAAYnH,SAyJtC,SAAS4H,GAAaC,EAAU9F,EAAO,GAAI,CAC9C,KAAM,CAAE+F,UAAAA,EAAWC,QAAAA,EAASC,KAAAA,EAAMC,SAAAA,EAAUC,KAAAA,CAAK,EAAIL,EAC/CM,EAAS,CAACF,GAAahF,MAAMC,QAAQ+E,CAAQ,GAAK,CAACA,EAASrH,OAC5DwH,EAAS,CACXpF,IAAK6E,EACLC,UAAAA,EACAC,QAASA,GAAWC,EACpBE,KAAAA,CACH,EACD,OAAOG,GAAQR,EAASpG,IAAI,EAAEwD,OAAO,CAACqD,EAAKC,IAAiB,CACxD,UAAWC,KAAgBlC,EAAgBiC,CAAY,EAAG,CACtD,MAAM9G,EAAOiB,GAAUX,EAAMyG,CAAY,EACzC,IAAIjF,EAAU4E,EAAS1G,EAAOA,EAAKgC,MAAM,KAAM,CAAC,EAAE,CAAC,EACnDF,EAAUA,EACLE,MAAM,GAAG,EACT4B,IAAK1D,GACCA,EAAEQ,WAAW,GAAG,GAAKR,EAAEQ,WAAW,GAAG,EAAIR,EAAI8G,mBAAmB9G,CAAC,CAC3E,EACI+C,KAAK,GAAG,EACb4D,EAAInF,KAAK,CACL,GAAGiF,EACHG,aAAAA,EACAhF,QAAAA,EACAmF,QAAStF,GAAcG,EAAS,CAAC4E,EAAQN,EAASvE,YAAY,CAClE,CAAC,CACL,CACA,OAAOgF,CACV,EAAE,EAAE,CACT,CACO,SAASK,GAAaC,EAAQnC,EAAQ,EAAG,CAC5C,MAAO,CACHmC,OAAAA,EACA1D,MAAOH,GAAW6D,EAAOA,EAAOhI,OAAS,CAAC,CAAC,EAAI,IAAQ6F,EACvDiC,QAAQ1I,EAAU,CACd,MAAM6I,EAAU,CAAE,EAClB,QAAS1E,EAAIyE,EAAOhI,OAAS,EAAGuD,GAAK,EAAGA,IAAK,CACzC,MAAMa,EAAQ4D,EAAOzE,CAAC,EAChBF,EAAQe,EAAM0D,QAAQ1I,CAAQ,EACpC,GAAI,CAACiE,EACD,OAAO,KAEX4E,EAAQC,QAAQ,CACZ,GAAG7E,EACHe,MAAAA,CACJ,CAAC,CACL,CACA,OAAO6D,CACX,CACH,CACL,CACA,SAASR,GAAQ9F,EAAO,CACpB,OAAOU,MAAMC,QAAQX,CAAK,EAAIA,EAAQ,CAACA,CAAK,CAChD,CACO,SAASwG,GAAelB,EAAU9F,EAAO,GAAIiH,EAAQ,CAAE,EAAEC,EAAW,GAAI,CAC3E,MAAMC,EAAYb,GAAQR,CAAQ,EAClC,QAAS1D,EAAI,EAAGN,EAAMqF,EAAUtI,OAAQuD,EAAIN,EAAKM,IAAK,CAClD,MAAMgF,EAAMD,EAAU/E,CAAC,EACvB,GAAIgF,GAAO,OAAOA,GAAQ,SAAU,CAC3BA,EAAIC,eAAe,MAAM,IAC1BD,EAAI1H,KAAO,IACf,MAAMmH,EAAShB,GAAauB,EAAKpH,CAAI,EACrC,UAAWiD,KAAS4D,EAAQ,CACxBI,EAAM7F,KAAK6B,CAAK,EAChB,MAAMqE,EAAepG,MAAMC,QAAQiG,EAAIlB,QAAQ,GAAKkB,EAAIlB,SAASrH,SAAW,EAC5E,GAAIuI,EAAIlB,UAAY,CAACoB,EACjBN,GAAeI,EAAIlB,SAAUjD,EAAMzB,QAASyF,EAAOC,CAAQ,MAE1D,CACD,MAAMK,EAASX,GAAa,CAAC,GAAGK,CAAK,EAAGC,EAASrI,MAAM,EACvDqI,EAAS9F,KAAKmG,CAAM,CACxB,CACAN,EAAMO,IAAK,CACf,CACJ,CACJ,CAEA,OAAOP,EAAMpI,OAASqI,EAAWA,EAASO,KAAK,CAACC,EAAGC,IAAMA,EAAExE,MAAQuE,EAAEvE,KAAK,CAC9E,CACO,SAASyE,EAAgBV,EAAUjJ,EAAU,CAChD,QAASmE,EAAI,EAAGN,EAAMoF,EAASrI,OAAQuD,EAAIN,EAAKM,IAAK,CACjD,MAAMF,EAAQgF,EAAS9E,CAAC,EAAEuE,QAAQ1I,CAAQ,EAC1C,GAAIiE,EACA,OAAOA,CAEf,CACA,MAAO,CAAE,CACb,CACA,SAAS2F,GAAenI,EAAMhB,EAAOoJ,EAAc,CAC/C,MAAMC,EAAS,IAAIC,IAAIxI,EAAQ,EACzBqB,EAAMoD,EAAWgE,GAAQ,CAC3B,MAAMC,EAAQxI,EAAM,EACpB,GAAI,CACA,OAAO,IAAIsI,IAAIE,EAAOH,CAAM,CAC/B,MACW,CACRI,eAAQC,MAAM,gBAAgBF,CAAK,EAAE,EAC9BD,CACX,CACH,EAAEF,EAAQ,CACPM,OAAQA,CAACX,EAAGC,IAAMD,EAAEY,OAASX,EAAEW,IACnC,CAAC,EACKC,EAAWtE,EAAW,IAAMpD,EAAG,EAAG0H,QAAQ,EAC1CC,EAASvE,EAAW,IAAMpD,EAAG,EAAG2H,OAAQ,EAAI,EAC5CC,EAAOxE,EAAW,IAAMpD,EAAG,EAAG4H,IAAI,EAClCxH,EAAMA,IAAM,GACZyH,EAAUC,EAAGH,EAAQ,IAAM5H,EAAoBC,EAAG,CAAE,CAAC,EAC3D,MAAO,CACH,IAAI0H,UAAW,CACX,OAAOA,EAAU,CACpB,EACD,IAAIC,QAAS,CACT,OAAOA,EAAQ,CAClB,EACD,IAAIC,MAAO,CACP,OAAOA,EAAM,CAChB,EACD,IAAI/J,OAAQ,CACR,OAAOA,EAAO,CACjB,EACD,IAAIuC,KAAM,CACN,OAAOA,EAAK,CACf,EACD2H,MAAOd,EAAeA,EAAaY,CAAO,EAAItF,EAAiBsF,CAAO,CACzE,CACL,CACA,IAAIG,EACG,SAASC,IAAY,CACxB,OAAOD,CACX,CAQO,SAASE,GAAoBC,EAAa9B,EAAU+B,EAAYtL,EAAU,CAAA,EAAI,CACjF,KAAM,CAAEuL,OAAQ,CAACC,EAAQC,CAAS,EAAGC,MAAAA,EAAQ,CAAA,CAAG,EAAIL,EAC9CM,EAAYD,EAAMC,YAAcvE,GAAKA,GACrCY,EAAa0D,EAAM1D,aAAeZ,GAAKA,GACvCwE,EAAcF,EAAME,aAAetM,GAAmB,EACtDgD,EAAWF,EAAY,GAAIpC,EAAQqC,MAAQ,EAAE,EACnD,GAAIC,IAAagC,OACb,MAAM,IAAIvB,MAAM,GAAGT,CAAQ,2BAA2B,EAEjDA,GAAY,CAACkJ,EAAM,EAAG3I,OAC3B4I,EAAU,CAAE5I,MAAOP,EAAUJ,QAAS,GAAM2J,OAAQ,EAAM,CAAC,EAE/D,KAAM,CAACC,EAAWC,CAAY,EAAIC,EAAa,EAAK,EAEpD,IAAIC,EAEJ,MAAMC,EAAaA,CAACC,EAAWC,IAAc,CACrCA,EAAUvJ,QAAUwJ,EAAS,GAAMD,EAAUrL,QAAUA,MAEvDkL,IAAyB3H,QACzByH,EAAa,EAAI,EACrBb,EAASiB,EACTF,EAAuBG,EACvBE,GAAgB,IAAM,CACdL,IAAyBG,IAE7BG,EAAaN,EAAqBpJ,KAAK,EACvC2J,GAASP,EAAqBlL,KAAK,EACnC0L,GAAsB,EACjBtL,GACDuL,EAAY,CAAC,EAAEC,GAAQA,EAAK1I,OAAOhC,GAAKA,EAAE2K,OAAO,CAAC,EAC1D,CAAC,EAAEC,QAAQ,IAAM,CACTZ,IAAyBG,GAG7BU,GAAM,IAAM,CACR5B,EAAS5G,OACL6H,IAAc,YACdY,GAAYd,CAAoB,EACpCF,EAAa,EAAK,EAClBE,EAAuB3H,MAC3B,CAAC,CACL,CAAC,EACJ,EACK,CAAC+H,EAAWE,CAAY,EAAIP,EAAaR,EAAQ,EAAC3I,KAAK,EACvD,CAAC9B,EAAOyL,EAAQ,EAAIR,EAAaR,EAAQ,EAACzK,KAAK,EAC/CT,EAAW4J,GAAemC,EAAWtL,EAAO2K,EAAMvB,YAAY,EAC9D6C,EAAY,CAAE,EACdN,EAAcV,EAAa7K,EAAW8L,GAAa,EAAK,CAAA,CAAE,EAC1D9D,EAAU7C,EAAW,IACnB,OAAOtG,EAAQkN,cAAiB,WACzBjD,EAAgBV,IAAYvJ,EAAQkN,aAAa5M,EAASsK,QAAQ,CAAC,EAEvEX,EAAgBV,IAAYjJ,EAASsK,QAAQ,CACvD,EACKuC,EAAcA,IAAM,CACtB,MAAMC,EAAIjE,EAAS,EACbhG,EAAS,CAAE,EACjB,QAASsB,EAAI,EAAGA,EAAI2I,EAAElM,OAAQuD,IAC1B4I,OAAOC,OAAOnK,EAAQiK,EAAE3I,CAAC,EAAEtB,MAAM,EAErC,OAAOA,CACV,EACKA,GAASuI,EAAM6B,cACf7B,EAAM6B,cAAcJ,EAAa5D,CAAQ,EACzC9D,EAAiB0H,CAAW,EAC5BK,EAAY,CACd3J,QAASvB,EACTP,KAAMA,IAAMO,EACZmL,OAAQA,IAAM,KACdrL,YAAYrC,EAAI,CACZ,OAAOqC,EAAYE,EAAUvC,CAAE,CACnC,CACH,EAED2N,OAAAA,GAAmB1C,EAAGQ,EAAQA,GAAUU,EAAW,SAAUV,CAAM,EAAG,CAAEmC,MAAO,EAAK,CAAC,CAAC,EAC/E,CACHtL,KAAMmL,EACNlN,SAAAA,EACA6C,OAAAA,GACA2I,UAAAA,EACA9D,WAAAA,EACA2D,UAAAA,EACAiC,iBAAAA,GACAzE,QAAAA,EACAyC,YAAAA,EACAiC,aAAAA,GACAC,aAAc9N,EAAQ8N,eAAiBxJ,OAAY,GAAOtE,EAAQ8N,aAClEpB,YAAAA,CACH,EACD,SAASqB,GAAkBzI,EAAOvF,EAAIC,EAAS,CAE3CgO,GAAQ,IAAM,CACV,GAAI,OAAOjO,GAAO,SAAU,CACnBA,IAGI2L,EAAMhK,GACXgK,EAAMhK,GAAG3B,CAAE,EAGXyK,QAAQyD,KAAK,sDAAsD,GAEvE,MACJ,CACA,MAAMC,EAAY,CAACnO,GAAMA,EAAG,CAAC,IAAM,IAC7B,CAAEmC,QAAAA,EAASxB,QAAAA,EAASmL,OAAAA,EAAQ9K,MAAOoN,CAAU,EAAI,CACnDjM,QAAS,GACTxB,QAAS,CAACwN,EACVrC,OAAQ,GACR,GAAG7L,CACN,EACKoO,EAAa1N,EACb4E,EAAMlD,YAAYrC,CAAE,EACpBqC,EAAa8L,GAAa5N,EAASsK,UAAa,GAAI7K,CAAE,EAC5D,GAAIqO,IAAe9J,OACf,MAAM,IAAIvB,MAAM,SAAShD,CAAE,0BAA0B,EAEpD,GAAIiN,EAAU9L,QAAUmG,GACzB,MAAM,IAAItE,MAAM,oBAAoB,EAExC,MAAMsL,EAAUhC,EAAW,EAC3B,GAAI+B,IAAeC,GAAWF,IAAcpN,EAAK,EAC7C,GAAII,EAAU,CACV,MAAMlB,EAAIqO,EAAiB,EAC3BrO,IAAMA,EAAEsO,SAAW,CAAEC,OAAQ,IAAKC,QAAS,IAAIC,QAAQ,CAAEC,SAAUP,CAAY,CAAA,CAAE,GACjF3C,EAAU,CAAE5I,MAAOuL,EAAYlM,QAAAA,EAAS2J,OAAAA,EAAQ9K,MAAOoN,CAAU,CAAC,CACrE,MACQvC,EAAY9L,QAAQsO,EAAYpO,CAAO,IAC5CgN,EAAUvJ,KAAK,CAAEZ,MAAOwL,EAASnM,QAAAA,EAAS2J,OAAAA,EAAQ9K,MAAOA,EAAK,CAAG,CAAC,EAClEmL,EAAW,WAAY,CACnBrJ,MAAOuL,EACPrN,MAAOoN,CACX,CAAC,EAGb,CAAC,CACL,CACA,SAASP,GAAiBtI,EAAO,CAE7BA,OAAAA,EAAQA,GAASoC,EAAWF,EAAe,GAAKgG,EACzC,CAACzN,EAAIC,IAAY+N,GAAkBzI,EAAOvF,EAAIC,CAAO,CAChE,CACA,SAAS+M,GAAY6B,EAAM,CACvB,MAAMC,EAAQ7B,EAAU,CAAC,EACrB6B,IACApD,EAAU,CACN,GAAGmD,EACH1M,QAAS2M,EAAM3M,QACf2J,OAAQgD,EAAMhD,MAClB,CAAC,EACDmB,EAAU9L,OAAS,EAE3B,CACA,SAAS2M,GAAa3K,EAAK4L,EAAa,CACpC,MAAM3F,EAAUc,EAAgBV,EAAQ,EAAIrG,EAAI0H,QAAQ,EAClDmE,EAAa7D,EACnBA,EAAS,UACT,QAAS3G,KAAS4E,EAAS,CACvB,KAAM,CAAE7D,MAAAA,EAAOnC,OAAAA,CAAO,EAAIgG,EAAQ5E,CAAK,EACvCe,EAAM8C,WACF9C,EAAM8C,UAAUC,SAChB/C,EAAM8C,UAAUC,QAAS,EAC7B,KAAM,CAAEA,QAAAA,CAAQ,EAAI/C,EAEpBwJ,GACIzG,GACAjC,EAAakF,EAAY,EAAE,IAAMjD,EAAQ,CACrClF,OAAAA,EACA7C,SAAU,CACNsK,SAAU1H,EAAI0H,SACdC,OAAQ3H,EAAI2H,OACZC,KAAM5H,EAAI4H,KACVG,MAAOhI,EAAoBC,CAAG,EAC9BnC,MAAO,KACPuC,IAAK,EACR,EACD4H,OAAQ,SACZ,CAAC,CAAC,CAEV,CACAA,EAAS6D,CACb,CACA,SAAS9B,IAAgB,CACrB,MAAMhN,EAAIqO,EAAiB,EAC3B,OAAQrO,GAAKA,EAAE6H,QAAU7H,EAAE6H,OAAOkH,WAAa,CAAC/O,EAAE6H,OAAOkH,UAAU,EAAI,CAAE,CAC7E,CACJ,CACO,SAASC,GAAmBnH,EAAQoH,EAAQzB,EAAQlJ,EAAO,CAC9D,KAAM,CAAElC,KAAAA,EAAM/B,SAAAA,EAAU6C,OAAAA,CAAO,EAAI2E,EAC7B,CAAEjE,QAAAA,EAASuE,UAAAA,EAAWC,QAAAA,CAAQ,EAAI9D,EAAO,EAACe,MAC1CvD,EAAOuE,EAAW,IAAM/B,EAAK,EAAGxC,IAAI,EAC1CqG,GACIA,EAAUC,SACVD,EAAUC,QAAS,EAEvB,MAAM8G,EAAO9G,EAAUA,EAAQ,CAAElF,OAAAA,EAAQ7C,SAAAA,EAAU4K,OAAQA,GAAU,SAAW,CAAA,EAAI5G,OAoBpF,MAlBc,CACV4K,OAAAA,EACArL,QAAAA,EACA9B,KAAAA,EACA0L,OAAQA,IAAMrF,EACRgH,GAAgBhH,EAAW,CACzBjF,OAAAA,EACA7C,SAAAA,EACA6O,KAAAA,EACA,IAAI5G,UAAW,CACX,OAAOkF,EAAQ,CACnB,CACH,CAAA,EACCA,EAAQ,EACdrL,YAAYrC,EAAI,CACZ,OAAOqC,EAAYC,EAAKN,KAAM,EAAEhC,EAAIgC,EAAI,CAAE,CAC9C,CACH,CAEL","x_google_ignoreList":[0,1,2]}